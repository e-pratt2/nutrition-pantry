package Search;

import java.util.*;
import java.util.function.Function;

/**
 * Holds the search results generated by FuzzySearch and provides helpers to access them.
 * @param <E>
 */
public class SearchResults<E> {
    private final SortedSet<Result> results;
    private final Function<E, String> stringifier;

    /**
     * Create a new results set.
     * @param stringifier The function to use when displaying the objects.
     */
    public SearchResults(Function<E, String> stringifier) {
        results = new TreeSet<>();
        this.stringifier = stringifier;
    }

    /**
     * A single result in the results. Holds an object and it's score, allowing for
     * printing it along with a visual representation of match strength.
     */
    public class Result implements Comparable<Result> {
        private final E object;
        private final float score;
        private final Function<E, String> stringifier;

        /**
         * Construct a result.
         * @param object The object who's score is represented
         * @param score The score of the object's match
         * @param stringifier The function to use when displaying the object.
         */
        public Result(E object, float score, Function<E, String> stringifier) {
            this.object = object;
            this.score = score;
            this.stringifier = stringifier;
        }

        /**
         * Retrieve the associated object
         * @return
         */
        public E getObject() {
            return object;
        }

        /**
         * Retrieve the associated score
         * @return
         */
        public float getScore() {
            return score;
        }

        /**
         * Compare only the scores of two results. Helpful for sorting for best results.
         * @param other The Result to compare to
         * @return -1 if this is less, 0 if this is equal, 1 if this is more.
         */
        @Override
        public int compareTo(Result other) {
            return Float.compare(score, other.score);
        }

        /**
         * Generate a string in the form `[***  ]` where the number of stars represents the strength of
         * the match.
         * @return a visual representation of the score.
         */
        private String percentageString() {
            int numStars = Math.round(this.score * 5);
            return "[" + "*".repeat(numStars) + " ".repeat(5-numStars) + "]";
        }

        /**
         * Apply the stringify function, along with the visual representation of the score.
         * @return the stringified version, with the object and score shown.
         */
        @Override
        public String toString() {
            return percentageString() + " " + stringifier.apply(object);
        }
    }

    /**
     * Add a result to the results set.
     * @param item The object who's score is being added
     * @param score The score of the object.
     */
    public void pushResult(E item, float score) {
        results.add(new Result(item, score, stringifier));
    }


    /**
     * Get a sublist of the best of the results, limiting to the top <`limit`> objects. Eg. limit = 5 returns the best
     * 5 objects.
     * @param limit the number of objects to limit to
     * @return the list of best results, size <= limit.
     */
    public List<Result> getBestResults(int limit) {
        ArrayList<Result> bestResults = new ArrayList<>(results);

        int sublistStart = Math.max(bestResults.size() - limit, 0);

        List<Result> limitedResults = bestResults.subList(sublistStart, bestResults.size());

        Collections.reverse(limitedResults);

        return limitedResults;
    }
}
